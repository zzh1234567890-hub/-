from flask import Flask, render_template, request, jsonify, session, redirect, url_for, flash
import mysql.connector
from mysql.connector import Error
import pandas as pd
import numpy as np
import joblib
import json
from datetime import datetime, timedelta
import warnings
import os
import hashlib
import secrets
from werkzeug.security import generate_password_hash, check_password_hash
from functools import wraps

warnings.filterwarnings('ignore')

app = Flask(__name__)
app.secret_key = 'your-secret-key-change-this-in-production'  # åœ¨ç”Ÿäº§ç¯å¢ƒä¸­æ›´æ”¹æ­¤å¯†é’¥

# æ•°æ®åº“é…ç½®
DB_CONFIG = {
    'host': 'localhost',
    'user': 'root',
    'password': 'lcy1106',
    'database': 'å•†å“æˆ¿ä»·æ ¼'
}


class DatabaseManager:
    def __init__(self, config):
        self.config = config

    def get_connection(self):
        try:
            return mysql.connector.connect(**self.config)
        except Error as e:
            print(f"æ•°æ®åº“è¿æ¥é”™è¯¯: {e}")
            return None

    def execute_query(self, query, params=None):
        conn = self.get_connection()
        if not conn:
            return None

        try:
            cursor = conn.cursor(dictionary=True)
            cursor.execute(query, params or ())
            result = cursor.fetchall()
            return result
        except Error as e:
            print(f"æŸ¥è¯¢é”™è¯¯: {e}")
            return None
        finally:
            if conn.is_connected():
                cursor.close()
                conn.close()

    def execute_update(self, query, params=None):
        conn = self.get_connection()
        if not conn:
            return False

        try:
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            conn.commit()
            affected_rows = cursor.rowcount
            return affected_rows > 0
        except Error as e:
            print(f"æ›´æ–°é”™è¯¯: {e}")
            conn.rollback()
            return False
        finally:
            if conn.is_connected():
                cursor.close()
                conn.close()


db = DatabaseManager(DB_CONFIG)


class UserManager:
    def __init__(self, db_manager):
        self.db = db_manager

    def create_user(self, username, email, password, full_name):
        """åˆ›å»ºæ–°ç”¨æˆ·"""
        password_hash = generate_password_hash(password)
        query = """
        INSERT INTO users (username, email, password_hash, full_name)
        VALUES (%s, %s, %s, %s)
        """
        return self.db.execute_update(query, (username, email, password_hash, full_name))

    def authenticate_user(self, username, password):
        """éªŒè¯ç”¨æˆ·ç™»å½•"""
        query = "SELECT * FROM users WHERE username = %s AND is_active = TRUE"
        users = self.db.execute_query(query, (username,))

        if users and check_password_hash(users[0]['password_hash'], password):
            # æ›´æ–°æœ€åç™»å½•æ—¶é—´
            update_query = "UPDATE users SET last_login = NOW() WHERE id = %s"
            self.db.execute_update(update_query, (users[0]['id'],))
            return users[0]
        return None

    def get_user_by_id(self, user_id):
        """æ ¹æ®IDè·å–ç”¨æˆ·"""
        query = "SELECT * FROM users WHERE id = %s AND is_active = TRUE"
        users = self.db.execute_query(query, (user_id,))
        return users[0] if users else None

    def create_session(self, user_id):
        """åˆ›å»ºç”¨æˆ·ä¼šè¯"""
        session_token = secrets.token_urlsafe(32)
        expires_at = datetime.now() + timedelta(days=7)  # 7å¤©è¿‡æœŸ

        query = """
        INSERT INTO user_sessions (user_id, session_token, expires_at)
        VALUES (%s, %s, %s)
        """
        if self.db.execute_update(query, (user_id, session_token, expires_at)):
            return session_token
        return None

    def validate_session(self, session_token):
        """éªŒè¯ä¼šè¯"""
        query = """
        SELECT s.*, u.* FROM user_sessions s
        JOIN users u ON s.user_id = u.id
        WHERE s.session_token = %s AND s.expires_at > NOW() AND s.is_active = TRUE AND u.is_active = TRUE
        """
        sessions = self.db.execute_query(query, (session_token,))
        return sessions[0] if sessions else None

    def invalidate_session(self, session_token):
        """ä½¿ä¼šè¯å¤±æ•ˆ"""
        query = "UPDATE user_sessions SET is_active = FALSE WHERE session_token = %s"
        return self.db.execute_update(query, (session_token,))


user_manager = UserManager(db)


def login_required(f):
    """ç™»å½•éªŒè¯è£…é¥°å™¨"""

    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return redirect(url_for('login'))
        return f(*args, **kwargs)

    return decorated_function


class HousePricePredictor:
    def __init__(self):
        self.traditional_models = {}
        self.deep_learning_model = None
        self.scaler = None
        self.label_encoders = {}
        self.feature_columns = []
        self.model_info = {}
        self.load_models()

    def load_models(self):
        try:
            if not os.path.exists('models') or not os.path.exists('models/model_info.pkl'):
                print("æ¨¡å‹æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¯·å…ˆè¿è¡Œ model_trainer.py è®­ç»ƒæ¨¡å‹")
                return False

            # åŠ è½½æ¨¡å‹ä¿¡æ¯
            self.model_info = joblib.load('models/model_info.pkl')
            self.feature_columns = self.model_info['feature_columns']

            # åŠ è½½æ ‡å‡†åŒ–å™¨å’Œç¼–ç å™¨
            if os.path.exists('models/scaler.pkl'):
                self.scaler = joblib.load('models/scaler.pkl')
                print("âœ… æˆåŠŸåŠ è½½æ ‡å‡†åŒ–å™¨")

            if os.path.exists('models/label_encoders.pkl'):
                self.label_encoders = joblib.load('models/label_encoders.pkl')
                print(f"âœ… åŠ è½½äº† {len(self.label_encoders)} ä¸ªæ ‡ç­¾ç¼–ç å™¨")

            # åŠ è½½ä¼ ç»Ÿæœºå™¨å­¦ä¹ æ¨¡å‹
            model_names = ['random_forest', 'gradient_boosting', 'linear_regression', 'svr']
            for name in model_names:
                model_path = f'models/{name}_model.pkl'
                if os.path.exists(model_path):
                    self.traditional_models[name] = joblib.load(model_path)

            # åŠ è½½æ·±åº¦å­¦ä¹ æ¨¡å‹ï¼ˆä½¿ç”¨SavedModelæ ¼å¼ï¼‰
            if self.model_info.get('tensorflow_available', False):
                try:
                    import tensorflow as tf
                    if os.path.exists('models/neural_network_model'):
                        self.deep_learning_model = tf.keras.models.load_model('models/neural_network_model')
                        print("âœ… æˆåŠŸåŠ è½½æ·±åº¦å­¦ä¹ æ¨¡å‹")
                except Exception as e:
                    print(f"âš ï¸ åŠ è½½æ·±åº¦å­¦ä¹ æ¨¡å‹å¤±è´¥: {e}")

            total_models = len(self.traditional_models) + (1 if self.deep_learning_model else 0)
            print(
                f"âœ… æˆåŠŸåŠ è½½ {total_models} ä¸ªæ¨¡å‹ (ä¼ ç»Ÿ: {len(self.traditional_models)}, æ·±åº¦å­¦ä¹ : {1 if self.deep_learning_model else 0})")
            return True

        except Exception as e:
            print(f"âŒ åŠ è½½æ¨¡å‹å¤±è´¥: {e}")
            import traceback
            traceback.print_exc()
            return False

    def predict(self, features, model_name):
        try:
            if self.scaler is None:
                print("âŒ æ ‡å‡†åŒ–å™¨æœªåŠ è½½")
                return 0

            # ä¼ ç»Ÿæœºå™¨å­¦ä¹ æ¨¡å‹é¢„æµ‹
            if model_name in self.traditional_models:
                model = self.traditional_models[model_name]

                if model_name == 'svr':
                    features_scaled = self.scaler.transform([features])
                    prediction = model.predict(features_scaled)[0]
                else:
                    prediction = model.predict([features])[0]

                return max(0, prediction)

            # æ·±åº¦å­¦ä¹ æ¨¡å‹é¢„æµ‹
            elif model_name == 'neural_network' and self.deep_learning_model is not None:
                features_scaled = self.scaler.transform([features])
                prediction = self.deep_learning_model.predict(features_scaled, verbose=0)[0][0]
                return max(0, prediction)

            else:
                print(f"âš ï¸ æœªæ‰¾åˆ°æ¨¡å‹: {model_name}")
                return 0

        except Exception as e:
            print(f"âŒ é¢„æµ‹é”™è¯¯ ({model_name}): {e}")
            import traceback
            traceback.print_exc()
            return 0

    def get_model_comparison(self):
        return self.model_info.get('model_scores', {})


predictor = HousePricePredictor()


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']

        user = user_manager.authenticate_user(username, password)
        if user:
            session['user_id'] = user['id']
            session['username'] = user['username']
            session['full_name'] = user['full_name']
            flash('ç™»å½•æˆåŠŸï¼', 'success')
            return redirect(url_for('index'))
        else:
            flash('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯ï¼', 'error')

    return render_template('login.html')


@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        email = request.form['email']
        password = request.form['password']
        full_name = request.form['full_name']

        if user_manager.create_user(username, email, password, full_name):
            flash('æ³¨å†ŒæˆåŠŸï¼è¯·ç™»å½•ã€‚', 'success')
            return redirect(url_for('login'))
        else:
            flash('æ³¨å†Œå¤±è´¥ï¼ç”¨æˆ·åæˆ–é‚®ç®±å¯èƒ½å·²å­˜åœ¨ã€‚', 'error')

    return render_template('register.html')


@app.route('/logout')
def logout():
    session.clear()
    flash('å·²æˆåŠŸé€€å‡ºç™»å½•ï¼', 'info')
    return redirect(url_for('login'))


@app.route('/')
@login_required
def index():
    return render_template('index.html')


@app.route('/api/predict', methods=['POST'])
@login_required
def predict_price():
    try:
        data = request.json

        # æ„å»ºç‰¹å¾å­—å…¸
        feature_mapping = {
            'åœŸåœ°ç§»è½¬æ€»é¢ç§¯å¹³æ–¹å…¬å°º': float(data.get('land_area', 0)),
            'å»ºç‰©ç§»è½¬æ€»é¢ç§¯å¹³æ–¹å…¬å°º': float(data.get('building_area', 0)),
            'æˆ¿é¾„': float(data.get('age', 0)),
            'å»ºç‰©ç°å†µæ ¼å±€_æˆ¿': int(data.get('rooms', 0)),
            'å»ºç‰©ç°å†µæ ¼å±€_å…': int(data.get('halls', 0)),
            'å»ºç‰©ç°å†µæ ¼å±€_å«': int(data.get('bathrooms', 0)),
            'å­¦æ ¡_500å†…': int(data.get('school_nearby', 0)),
            'å…¬å›­_500å†…': int(data.get('park_nearby', 0)),
            'å…¬äº¤è½¦ç«™_500å†…': int(data.get('bus_nearby', 0)),
            'æ·è¿ç«™_500å†…': int(data.get('mrt_nearby', 0)),
            'å«Œæ¶è®¾æ–½_500å†…': int(data.get('bad_facility_nearby', 0)),
            'äº”å¤§è¡Œåº“å¹³å‡æˆ¿è´·åˆ©ç‡(%)': float(data.get('loan_rate', 2.5)),
            'å¤±ä¸šç‡(%)': float(data.get('unemployment_rate', 3.5)),
            'æ€»æ¥¼å±‚æ•°': int(data.get('total_floors', 10)),
            'ç§»è½¬å±‚æ¬¡': int(data.get('floor', 5)),
            'ä¾¿åˆ©è®¾æ–½æŒ‡æ•°': float(data.get('convenience_index', 3)),
            'æˆ¿ä»·æ‰€å¾—æ¯”': float(data.get('price_income_ratio', 15)),
            'è´·æ¬¾è´Ÿæ‹…ç‡': float(data.get('loan_burden_ratio', 35)),
            'ç»¼åˆæ‰€å¾—æ€»é¢_å¹³å‡æ•°(ä¸‡å…ƒ)': float(data.get('average_income', 100)),
            'å¹´_å…¬å…ƒ': int(data.get('year', 2023)),
            'æœˆ': int(data.get('month', 6))
        }

        # æŒ‰ç…§è®­ç»ƒæ—¶çš„ç‰¹å¾é¡ºåºæ„å»ºç‰¹å¾å‘é‡
        features = []
        for col in predictor.feature_columns:
            features.append(feature_mapping.get(col, 0))

        print(f"ğŸ” é¢„æµ‹ç‰¹å¾å‘é‡é•¿åº¦: {len(features)}")
        print(f"ğŸ” é¢„æœŸç‰¹å¾æ•°é‡: {len(predictor.feature_columns)}")

        # ä½¿ç”¨æ‰€æœ‰æ¨¡å‹è¿›è¡Œé¢„æµ‹
        predictions = {}

        # ä¼ ç»Ÿæœºå™¨å­¦ä¹ æ¨¡å‹
        for model_name in predictor.traditional_models.keys():
            pred = predictor.predict(features, model_name)
            predictions[model_name] = {
                'price': round(pred, 2),
                'formatted': f"{pred:,.0f}",
                'type': 'traditional'
            }

        # æ·±åº¦å­¦ä¹ æ¨¡å‹
        if predictor.deep_learning_model is not None:
            pred = predictor.predict(features, 'neural_network')
            predictions['neural_network'] = {
                'price': round(pred, 2),
                'formatted': f"{pred:,.0f}",
                'type': 'deep_learning'
            }

        # è·å–æœ€ä½³æ¨¡å‹çš„é¢„æµ‹ç»“æœ
        best_traditional = predictor.model_info.get('best_traditional_model')
        best_deep_learning = predictor.model_info.get('best_deep_learning_model')

        best_prediction = None
        if best_deep_learning and best_deep_learning in predictions:
            best_prediction = predictions[best_deep_learning]
        elif best_traditional and best_traditional in predictions:
            best_prediction = predictions[best_traditional]
        elif predictions:
            best_prediction = list(predictions.values())[0]

        return jsonify({
            'success': True,
            'predictions': predictions,
            'best_prediction': best_prediction,
            'best_traditional_model': best_traditional,
            'best_deep_learning_model': best_deep_learning
        })

    except Exception as e:
        print(f"âŒ é¢„æµ‹APIé”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/data')
@login_required
def get_data():
    try:
        page = int(request.args.get('page', 1))
        limit = int(request.args.get('limit', 20))
        search = request.args.get('search', '')
        city_filter = request.args.get('city', '')

        offset = (page - 1) * limit

        # æ„å»ºæŸ¥è¯¢æ¡ä»¶
        where_conditions = ["1=1"]
        params = []

        if search:
            where_conditions.append("(`åœŸåœ°ä½ç½®å»ºç‰©é—¨ç‰Œ` LIKE %s OR `å¿å¸‚` LIKE %s OR `ä¹¡é•‡å¸‚åŒº` LIKE %s)")
            search_param = f"%{search}%"
            params.extend([search_param, search_param, search_param])

        if city_filter:
            where_conditions.append("`å¿å¸‚` = %s")
            params.append(city_filter)

        where_clause = " AND ".join(where_conditions)

        # æŸ¥è¯¢æ•°æ®
        query = f"""
        SELECT ID, `äº¤æ˜“å¹´æœˆæ—¥`, `å¿å¸‚`, `ä¹¡é•‡å¸‚åŒº`, `åœŸåœ°ä½ç½®å»ºç‰©é—¨ç‰Œ`, 
               `å»ºç‰©ç§»è½¬æ€»é¢ç§¯å¹³æ–¹å…¬å°º`, `æ€»ä»·å…ƒ`, `å•ä»·å…ƒå¹³æ–¹å…¬å°º`, 
               `æˆ¿é¾„`,
               `å»ºç‰©ç°å†µæ ¼å±€_æˆ¿`, `å»ºç‰©ç°å†µæ ¼å±€_å…`, `å»ºç‰©ç°å†µæ ¼å±€_å«`
        FROM house_price 
        WHERE {where_clause}
        ORDER BY ID DESC
        LIMIT {limit} OFFSET {offset}
        """

        data = db.execute_query(query, params)

        # è·å–æ€»æ•°
        count_query = f"SELECT COUNT(*) as total FROM house_price WHERE {where_clause}"
        count_result = db.execute_query(count_query, params)
        total = count_result[0]['total'] if count_result else 0

        return jsonify({
            'success': True,
            'data': data,
            'total': total,
            'page': page,
            'limit': limit
        })
    except Exception as e:
        print(f"âŒ æ•°æ®æŸ¥è¯¢é”™è¯¯: {e}")
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/cities')
@login_required
def get_cities():
    try:
        query = "SELECT DISTINCT `å¿å¸‚` FROM house_price ORDER BY `å¿å¸‚`"
        data = db.execute_query(query)
        cities = [row['å¿å¸‚'] for row in data] if data else []
        return jsonify({'success': True, 'cities': cities})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/map_data')
@login_required
def get_map_data():
    try:
        city = request.args.get('city', '')
        limit = int(request.args.get('limit', 500))

        where_clause = """
        `çº¬åº¦` IS NOT NULL AND `ç»åº¦` IS NOT NULL 
        AND `çº¬åº¦` != 0 AND `ç»åº¦` != 0 
        AND `çº¬åº¦` BETWEEN 20 AND 30 
        AND `ç»åº¦` BETWEEN 115 AND 125
        """
        params = []

        if city:
            where_clause += " AND `å¿å¸‚` = %s"
            params.append(city)

        query = f"""
        SELECT `çº¬åº¦`, `ç»åº¦`, `æ€»ä»·å…ƒ`, `å¿å¸‚`, `ä¹¡é•‡å¸‚åŒº`, `åœŸåœ°ä½ç½®å»ºç‰©é—¨ç‰Œ`,
               `å»ºç‰©ç§»è½¬æ€»é¢ç§¯å¹³æ–¹å…¬å°º`, `å•ä»·å…ƒå¹³æ–¹å…¬å°º`, `æˆ¿é¾„`
        FROM house_price 
        WHERE {where_clause}
        ORDER BY RAND()
        LIMIT {limit}
        """

        data = db.execute_query(query, params)
        return jsonify({'success': True, 'data': data or []})
    except Exception as e:
        print(f"âŒ åœ°å›¾æ•°æ®æŸ¥è¯¢é”™è¯¯: {e}")
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/price_trend')
@login_required
def get_price_trend():
    try:
        city = request.args.get('city', '')

        where_clause = "`å•ä»·å…ƒå¹³æ–¹å…¬å°º` > 0 AND `å¹´_å…¬å…ƒ` IS NOT NULL AND `æœˆ` IS NOT NULL"
        params = []

        if city:
            where_clause += " AND `å¿å¸‚` = %s"
            params.append(city)

        query = f"""
        SELECT `å¿å¸‚`, `å¹´_å…¬å…ƒ`, `æœˆ`, 
               AVG(`å•ä»·å…ƒå¹³æ–¹å…¬å°º`) as avg_price,
               COUNT(*) as transaction_count
        FROM house_price 
        WHERE {where_clause}
        GROUP BY `å¿å¸‚`, `å¹´_å…¬å…ƒ`, `æœˆ`
        HAVING transaction_count >= 3
        ORDER BY `å¹´_å…¬å…ƒ`, `æœˆ`
        LIMIT 1000
        """

        data = db.execute_query(query, params)

        if not data:
            return jsonify({'success': True, 'data': {}})

        # æŒ‰åŸå¸‚åˆ†ç»„æ•°æ®
        trend_data = {}
        for row in data:
            city_name = row['å¿å¸‚']
            if city_name not in trend_data:
                trend_data[city_name] = []

            trend_data[city_name].append({
                'date': f"{row['å¹´_å…¬å…ƒ']}-{row['æœˆ']:02d}-01",
                'price': round(float(row['avg_price']), 2),
                'count': row['transaction_count']
            })

        return jsonify({'success': True, 'data': trend_data})
    except Exception as e:
        print(f"âŒ ä»·æ ¼è¶‹åŠ¿æŸ¥è¯¢é”™è¯¯: {e}")
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/transaction_volume')
@login_required
def get_transaction_volume():
    try:
        city = request.args.get('city', '')

        where_clause = "1=1"
        params = []

        if city:
            where_clause += " AND `å¿å¸‚` = %s"
            params.append(city)

        query = f"""
        SELECT `å¿å¸‚`, `ä¹¡é•‡å¸‚åŒº`, COUNT(*) as volume,
               AVG(`å•ä»·å…ƒå¹³æ–¹å…¬å°º`) as avg_price
        FROM house_price 
        WHERE {where_clause}
        GROUP BY `å¿å¸‚`, `ä¹¡é•‡å¸‚åŒº`
        ORDER BY volume DESC
        LIMIT 20
        """

        data = db.execute_query(query, params)
        return jsonify({'success': True, 'data': data})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/delete_record', methods=['POST'])
@login_required
def delete_record():
    try:
        record_id = request.json.get('id')
        query = "DELETE FROM house_price WHERE ID = %s"
        success = db.execute_update(query, (record_id,))
        return jsonify({'success': success})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/update_record', methods=['POST'])
@login_required
def update_record():
    try:
        data = request.json
        record_id = data.get('id')

        # æ„å»ºæ›´æ–°è¯­å¥
        update_fields = []
        params = []

        field_mapping = {
            'total_price': 'æ€»ä»·å…ƒ',
            'unit_price': 'å•ä»·å…ƒå¹³æ–¹å…¬å°º',
            'building_area': 'å»ºç‰©ç§»è½¬æ€»é¢ç§¯å¹³æ–¹å…¬å°º',
            'age': 'æˆ¿é¾„'
        }

        for key, db_field in field_mapping.items():
            if key in data and data[key] is not None:
                update_fields.append(f"`{db_field}` = %s")
                params.append(data[key])

        if not update_fields:
            return jsonify({'success': False, 'error': 'æ²¡æœ‰è¦æ›´æ–°çš„å­—æ®µ'})

        params.append(record_id)
        query = f"UPDATE house_price SET {', '.join(update_fields)} WHERE ID = %s"

        success = db.execute_update(query, params)
        return jsonify({'success': success})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/model_info')
@login_required
def get_model_info():
    try:
        model_comparison = predictor.get_model_comparison()
        return jsonify({
            'success': True,
            'model_scores': model_comparison,
            'best_traditional_model': predictor.model_info.get('best_traditional_model'),
            'best_deep_learning_model': predictor.model_info.get('best_deep_learning_model'),
            'feature_count': len(predictor.feature_columns),
            'tensorflow_available': predictor.model_info.get('tensorflow_available', False)
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})


if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
